<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Topographic Background</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #fff;
      height: 100vh;
    }
    #scroll-area {
      height: 100vh;
      position: relative;
    }
    #map {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
      cursor: crosshair;
      display: block;
      will-change: transform;
    }
  </style>
</head>
<body>
  <div id="scroll-area">
    <canvas id="map"></canvas>
  </div>

  <script>
    // PARAMETERS
    const GRID_STEP = 100;
    const SCALE = 0.01;
    const CONTOUR_INT = 30;
    const DS = 8;
    const dx = 5;
    const dy = 2.5;

    // PERLIN NOISE
    (function(global){
      var noise = global.noise = {};
      var grad3 = [[1,1],[-1,1],[1,-1],[-1,-1]];
      var p = [];
      for(let i = 0; i < 256; i++) p[i] = i;
      noise.seed = function(seed){
        let rand = () => (seed = (seed * 16807) % 2147483647, (seed - 1) / 2147483646);
        for (let i = 255; i > 0; i--) {
          let j = Math.floor(rand() * (i + 1));
          [p[i], p[j]] = [p[j], p[i]];
        }
        noise.perm = Array(512).fill().map((_, i) => p[i & 255]);
      };
      noise.perlin2 = function(x, y){
        let X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
        x -= Math.floor(x); y -= Math.floor(y);
        let fade = t => t*t*(3-2*t);
        let gi = (xi, yi) => noise.perm[xi + noise.perm[yi]] % 4;
        let grad = i => grad3[i];
        let dot = (g, x, y) => g[0]*x + g[1]*y;
        let u = fade(x), v = fade(y);
        let g00 = grad(gi(X, Y)), g01 = grad(gi(X, Y+1)),
            g10 = grad(gi(X+1, Y)), g11 = grad(gi(X+1, Y+1));
        return dot(g00,x,y)*(1-u)*(1-v) + dot(g10,x-1,y)*u*(1-v) +
               dot(g01,x,y-1)*(1-u)*v + dot(g11,x-1,y-1)*u*v;
      };
      noise.seed(1);
    })(this);

    const canvas = document.getElementById('map'),
          ctx    = canvas.getContext('2d');

    let w2, h2;
    function resizeCanvas(){
      canvas.width  = window.innerWidth;
      canvas.height = window.innerHeight;
      w2 = Math.ceil(canvas.width  / DS);
      h2 = Math.ceil(canvas.height / DS);
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function makeTextures(){
      const patterns = [];
      let c = document.createElement('canvas'), cx;
      // dot
      c.width = c.height = 20; cx = c.getContext('2d');
      cx.fillStyle = '#1449ff';
      [[5,5],[15,15]].forEach(([x,y])=>{ cx.beginPath(); cx.arc(x,y,3,0,2*Math.PI); cx.fill(); });
      patterns.push(ctx.createPattern(c, 'repeat'));
      // slash
      c.width = c.height = 20; cx = c.getContext('2d');
      cx.strokeStyle = '#1449ff'; cx.lineWidth = 2;
      cx.beginPath(); cx.moveTo(0,20); cx.lineTo(20,0); cx.stroke();
      patterns.push(ctx.createPattern(c, 'repeat'));
      // polka
      c.width = c.height = 30; cx = c.getContext('2d');
      cx.fillStyle = '#1449ff'; cx.beginPath(); cx.arc(15,15,5,0,2*Math.PI); cx.fill();
      patterns.push(ctx.createPattern(c, 'repeat'));
      // plus
      c.width = c.height = 20; cx = c.getContext('2d');
      cx.strokeStyle = '#1449ff'; cx.lineWidth = 2;
      cx.beginPath(); cx.moveTo(10,2); cx.lineTo(10,18); cx.moveTo(2,10); cx.lineTo(18,10); cx.stroke();
      patterns.push(ctx.createPattern(c, 'repeat'));
      // dollar
      c.width = c.height = 30; cx = c.getContext('2d');
      cx.fillStyle = '#1449ff'; cx.font = '20px sans-serif'; cx.fillText('$', 8, 22);
      patterns.push(ctx.createPattern(c, 'repeat'));
      return patterns;
    }
    const textures = makeTextures();

    function traceLoops(segs){
      const loops = [], edges = new Map();
      segs.forEach(({p1,p2})=>{
        edges.set(`${p1.x},${p1.y}`, p2);
        edges.set(`${p2.x},${p2.y}`, p1);
      });
      while(edges.size){
        const start = edges.keys().next().value;
        let curr = start, loop = [];
        do {
          const [x,y] = curr.split(',').map(Number);
          loop.push({x,y});
          const next = edges.get(curr);
          edges.delete(curr);
          curr = `${next.x},${next.y}`;
        } while(curr !== start && edges.has(curr));
        loops.push(loop);
      }
      return loops;
    }

    let offsetX = 0;

    function drawSlice(scrollY){
      const W = canvas.width, H = canvas.height;
      const sliceOffsetY = scrollY * SCALE;

      ctx.clearRect(0, 0, W, H);

      ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1; ctx.setLineDash([5,5]);
      for(let x = 0; x <= W; x += GRID_STEP){
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
      }
      for(let y = 0; y <= H; y += GRID_STEP){
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
      }
      ctx.setLineDash([]);

      const levels = Math.floor(255 / CONTOUR_INT);
      for(let i = 1; i <= levels; i++){
        const lvl = i * CONTOUR_INT, segs = [];
        for(let y = 0; y < h2 - 1; y++){
          for(let x = 0; x < w2 - 1; x++){
            const sample = (ix, iy) =>
              (noise.perlin2((ix + offsetX) * SCALE, (iy + sliceOffsetY) * SCALE) + 1) * 0.5 * 255;

            const x0 = x * DS, x1 = (x+1) * DS, y0 = y * DS, y1 = (y+1) * DS;
            const v0 = sample(x0, y0), v1 = sample(x1, y0), v2 = sample(x0, y1), v3 = sample(x1, y1);

            let m = 0;
            if (v0 > lvl) m |= 1;
            if (v1 > lvl) m |= 2;
            if (v2 > lvl) m |= 8;
            if (v3 > lvl) m |= 4;
            if (m === 0 || m === 15) continue;

            const xm = x + (lvl - v0) / ((v1 - v0) || 1),
                  ym = y + (lvl - v0) / ((v2 - v0) || 1),
                  xm2 = x + (lvl - v2) / ((v3 - v2) || 1),
                  ym2 = y + (lvl - v1) / ((v3 - v1) || 1);
            const add = (p1,p2) => segs.push({p1,p2});

            switch(m){
              case 1: case 14: add({x:x, y:ym}, {x:xm, y:y}); break;
              case 2: case 13: add({x:xm, y:y}, {x:x+1, y:ym2}); break;
              case 3: case 12: add({x:x, y:ym}, {x:x+1, y:ym2}); break;
              case 4: case 11: add({x:x+1, y:ym2}, {x:xm2, y:y+1}); break;
              case 5:
                add({x:x, y:ym}, {x:xm, y:y});
                add({x:x+1, y:ym2}, {x:xm2, y:y+1});
                break;
              case 6: case 9: add({x:xm, y:y}, {x:xm2, y:y+1}); break;
              case 7: case 8: add({x:x, y:ym}, {x:xm2, y:y+1}); break;
              case 10:
                add({x:xm, y:y}, {x:x+1, y:ym2});
                add({x:x, y:ym}, {x:xm2, y:y+1});
                break;
            }
          }
        }

        ctx.fillStyle = textures[(i-1)%textures.length];
        const loops = traceLoops(segs);
        loops.forEach(poly=>{
          ctx.beginPath();
          poly.forEach((pt,j)=>{
            const px = pt.x * DS, py = pt.y * DS;
            j ? ctx.lineTo(px, py) : ctx.moveTo(px, py);
          });
          ctx.closePath(); ctx.fill();
        });

        ctx.strokeStyle = '#1449ff'; ctx.lineWidth = 2; ctx.beginPath();
        const jf = 0.02, ja = 5;
        segs.forEach(s=>{
          const x1 = s.p1.x * DS, y1 = s.p1.y * DS;
          const x2 = s.p2.x * DS, y2 = s.p2.y * DS;
          const jx1 = (noise.perlin2((x1+offsetX)*jf, (y1+sliceOffsetY)*jf) - 0.5) * ja;
          const jy1 = (noise.perlin2((x1+100+offsetX)*jf, (y1+100+sliceOffsetY)*jf) - 0.5) * ja;
          const jx2 = (noise.perlin2((x2+offsetX)*jf, (y2+sliceOffsetY)*jf) - 0.5) * ja;
          const jy2 = (noise.perlin2((x2+100+offsetX)*jf, (y2+100+sliceOffsetY)*jf) - 0.5) * ja;
          ctx.moveTo(x1 + jx1, y1 + jy1);
          ctx.lineTo(x2 + jx2, y2 + jy2);
        });
        ctx.stroke();
      }

      offsetX += dx;
    }

    // THROTTLED SCROLL HANDLING
    let ticking = false;
    let lastDrawY = -Infinity;
    const SCROLL_STEP = 40;

    function handleScrollY(sy){
      if (Math.abs(sy - lastDrawY) >= SCROLL_STEP) {
        lastDrawY = sy;
        if (!ticking) {
          requestAnimationFrame(() => {
            drawSlice(lastDrawY);
            ticking = false;
          });
          ticking = true;
        }
      }
    }

    window.addEventListener('scroll', () => handleScrollY(window.scrollY));

    window.addEventListener('message', e => {
      if (e.data && typeof e.data.scrollY === 'number') {
        handleScrollY(e.data.scrollY);
      }
    });

    drawSlice(0);
  </script>
</body>
</html>
